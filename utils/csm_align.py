'''


Build ref HILIC+, RP+, HILIC-, RP- metabolomes.

Select CSM features with RTI, blood conc/papers, and likely unambiguous

Per dataset:
Primary features present in CSM. Regression to get RT dict.




blood_metabolites should have inchikey and major DB identifiers.
Metabolon annotations usually have HMDB IDs.



import statsmodels.api as sm
from mass2chem.lib.formula_coordinate import formula_coordinate
from jms.dbStructures import knownCompoundDatabase, ExperimentalEcpdDatabase
from asari.tools import match_features as mf




'''
import json
import csv
import numpy as np

from mining import get_M0


bmdb = '/Users/lish/li.proj/serum_consensus_metabolome/v6/blood_metabolites_20241215.json'

# to replace these two from notebook -

def extract_12c_landmark_features(list_khipus, ion='M0,M+H+'):
    '''
    parameters : list_khipus, generated by khipu algorithm. 'representative_intensity' required for features.
    
    returns landmark_features
    '''
    landmark_features = []
    for k in list_khipus:
        m0 = [f for f in k['MS1_pseudo_Spectra'] if f['ion_relation']==ion]
        if m0:
            landmark_features += m0
    return landmark_features

def get_primary_features_from_epds(infile_json, 
                                   natural_ratio_limit=0.5, 
                                   primary_ion='M0,M+H+'):
    '''
    Use khipu JSON result as input.
    Use primary_ion for pos or neg ionization data.
    Returns landmark_features, primary_features, singletons
    '''
    full = json.load(open(infile_json))
    # fix typing
    for epd in full:
        for f in epd["MS1_pseudo_Spectra"]:
            f['id'] = f['id_number']
            f['snr'] = float(f['snr'])
            f['goodness_fitting'] = float(f['goodness_fitting'])
            f['representative_intensity'] = f['peak_area'] = float(f['peak_area'])
            
    print("Total feature number", len(full))
    landmark_features, primary_features, singletons = [], [], []
    for epd in full:
        features = epd["MS1_pseudo_Spectra"]
        if len(features) == 1:
            singletons.append(features[0])
        else:
            M0, M1 = get_M0(features), get_M1(features)
            primary_features.append(M0)
            if M0 and M1 and M0['modification']==M1['modification'] and M0['ion_relation']==primary_ion:
                if float(M1['representative_intensity'])/(1 + float(
                    M0['representative_intensity'])) < natural_ratio_limit:
                    landmark_features.append( M0 )

    print("landmark_features, primary, singletons:", 
          len(landmark_features), len(primary_features), len(singletons))
    
    return landmark_features, primary_features, singletons


def convert_track2features(features):
    '''returns 
    tracks, and dict of massTrack to [features]'''
    tracks = []
    d = {}
    for f in features:
        t = f['parent_masstrack_id']
        if t in d:
            d[t].append(f['id'])
        else:
            d[t] = [f['id']]
            tracks.append({
                'id': t,
                'mz': f['mz'],
                'rtime': 0,
                'members': []
            })
    for track in tracks:
        track['members'] = d[track['id']]
    return tracks, d

def convert_csmfs2tracks(csmfs):
    '''
    Example ref_csmfs :     {'id': 'r1_pos_1274.858866_HILIC_0',
                                'ion': '',
                                'neuMR': 'r1_neu_1273.851586',
                                'mz': 1274.858866,
                                'rti': None,
                                'number_isomers': 1,
                                'isomer_elution_order': 0,
                                'annotation_reported': 'MDB0094924r1'}
    '''
    tracks = []
    d = {}
    for f in csmfs:
        t = '_'.join(f['id'].split('_')[:-2])
        if t in d:
            d[t].append(f['id'])
        else:
            d[t] = [f['id']]
            tracks.append({
                'id': t,
                'mz': f['mz'],
                'rtime': 0,
                'members': []
            })
    for track in tracks:
        track['members'] = d[track['id']]
    return tracks, d

def align_user_features_to_csm(primary_features, singletons, 
                               list_csmf,
                               slope=1, intercept=0,
                               exact_isomer_numbers=False
                               ):
    '''
    return fully matched list for annotation of user data.
    exact_isomer_numbers : force identical number of isomers
    
    This has to be two-layers: features and massTracks.
    massTracks matches should be unique
    returns matched primary_features, singletons; and mapping dict.
    
    slope, intercept, - to add for RTI cal
    
    
    '''
    fTracks, dict_fTracks = convert_track2features(primary_features + singletons)
    csmfTracks, dict_csmfTracks = convert_csmfs2tracks(list_csmf)
    
    dict_features, dict_csmfs = {}, {}
    for f in primary_features + singletons:
        dict_features[f['id']] = f
    for c in list_csmf:
        dict_csmfs[c['id']] = c
    
    matched = mf.best_mz_match_lcms_features(
                    csmfTracks, fTracks, mz_ppm=5, rt_tolerance=1e20
                    )  # returns f -f dict
    
    clean_dict_match = get_clean_dict_match(
        matched, dict_csmfTracks, dict_fTracks, dict_csmfs, dict_features
        )
    return clean_dict_match
    
def get_clean_dict_match(matched, dict_csmfTracks, dict_fTracks, 
                         dict_csmfs, dict_features):
    '''
    matched as dict (m/z matches)
    '''
    new = {}
    for k,v in matched.items():
        # at track level, massTracks matches should be unique
        csmfs = dict_csmfTracks[k]
        features = dict_fTracks[v]
        resolved_pairs = resolve_multiple_match(
            csmfs, features, dict_csmfs, dict_features) # at feature level
        for x,y in resolved_pairs:
            new[x] = y
    return new

def match_csmf_features_equal_n(csmfs, features, dict_csmfs, dict_features):
    # match elution order
    ordered_csmfs = sorted(csmfs, key=lambda x: dict_csmfs[x]['isomer_elution_order'])
    ordered_features = sorted(features, key=lambda x: dict_features[x]['rtime'])
    return list(zip(ordered_csmfs, ordered_features))

def resolve_multiple_match(csmfs, features, dict_csmfs, dict_features):
    '''
    resolve multiple matches btw features and CSMFs on the same track.
    This is based on 
    - matching elution order
    - later ... prioritization of annotations and MDB records by signal levels.
    '''
    N_csmf, N_features = len(csmfs), len(features)
    if N_csmf == 1 and N_features == 1:
        return [(csmfs[0], features[0])]
    elif N_csmf > N_features:
        return []   # will resolve later using BMDB information
    elif N_csmf == N_features:
        return match_csmf_features_equal_n(csmfs, features, dict_csmfs, dict_features)
    else:
        # N_csmf < N_features, sort features by abundance; take first matched N
        sel_features = sorted(features, 
                    key=lambda x: dict_features[x]['peak_area'], reverse=True
                    )[:N_csmf]
        return match_csmf_features_equal_n(csmfs, sel_features, dict_csmfs, dict_features)
